---
title: LocalIrpProcessing rule set (WDM)
description: Use these rules to verify that your driver correctly handles I/O request packets (IRP) that are created by the driver.
ms.assetid: 2D10086F-4FCB-4BB1-AF63-49625DCA1A44
ms.author: windowsdriverdev
ms.date: 05/21/2018
ms.topic: article
ms.prod: windows-hardware
ms.technology: windows-devices
ms.localizationpriority: medium
---

# LocalIrpProcessing rule set (WDM)


Use these rules to verify that your driver correctly handles I/O request packets (IRP) that are created by the driver.

## In this section


<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Topic</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p>[<strong>IoAllocateComplete</strong>](wdm-ioallocatecomplete.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateComplete</strong>](wdm-ioallocatecomplete.md) rule specifies that a driver should not call [<strong>IoCompleteRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548343) if the IRP was created with [<strong>IoAllocateIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548257).</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoAllocateFree</strong>](wdm-ioallocatefree.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateFree</strong>](wdm-ioallocatefree.md) rule specifies that a driver should use [<strong>IoFreeIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff549113) only on IRPs that were previously allocated with [<strong>IoAllocateIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548257).</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoAllocateForward</strong>](wdm-ioallocateforward.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateForward</strong>](wdm-ioallocateforward.md) rule specifies that if an IRP is generated by a call to [<strong>IoAllocateIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548257), the driver must set a completion routine before calling [<strong>IoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548336) or [<strong>PoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff559654).</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoAllocateIrpSignalEventInCompletion</strong>](wdm-ioallocateirpsignaleventincompletion.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateIrpSignalEventInCompletion</strong>](wdm-ioallocateirpsignaleventincompletion.md) rule specifies that the driver should call [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoAllocateIrpSignalEventInCompletion2</strong>](wdm-ioallocateirpsignaleventincompletion2.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateIrpSignalEventInCompletion2</strong>](wdm-ioallocateirpsignaleventincompletion2.md) rule specifies that [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) needs to be called in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoAllocateIrpSignalEventInCompletion3</strong>](wdm-ioallocateirpsignaleventincompletion3.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateIrpSignalEventInCompletion3</strong>](wdm-ioallocateirpsignaleventincompletion3.md) rule specifies that [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) needs to be called in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoAllocateIrpSignalEventInCompletionTimeout</strong>](wdm-ioallocateirpsignaleventincompletiontimeout.md)</p></td>
<td align="left"><p>The [<strong>IoAllocateIrpSignalEventInCompletionTimeout</strong>](wdm-ioallocateirpsignaleventincompletiontimeout.md) rule reports a defect if it detects that this driver will wait indefinitely until the lower driver returns, as the IRP’s event is required to be signaled in the completion routine.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildDeviceControlNoFree</strong>](wdm-iobuilddevicecontrolnofree.md)</p></td>
<td align="left"><p>The [<strong>IoBuildDeviceControlNoFree</strong>](wdm-iobuilddevicecontrolnofree.md) rule specifies that a driver that calls [<strong>IoBuildDeviceIoControlRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548318) must not call [<strong>IoFreeIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff549113).</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildDeviceControlWait</strong>](wdm-iobuilddevicecontrolwait.md)</p></td>
<td align="left"><p>The [<strong>IoBuildDeviceControlWait</strong>](wdm-iobuilddevicecontrolwait.md) rule specifies that the [<strong>KeWaitForSingleObject</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553350) routine should be called if [<strong>IoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548336) or [<strong>PoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff559654) returns STATUS_PENDING.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildDeviceControlWaitTimeout</strong>](wdm-iobuilddevicecontrolwaittimeout.md)</p></td>
<td align="left"><p>The [<strong>IoBuildDeviceControlWaitTimeout</strong>](wdm-iobuilddevicecontrolwaittimeout.md) rule reports a defect if it detects that this driver will wait indefinitely until the lower driver returns, as the IRP’s event is required to be signaled in the completion routine.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildDeviceIoControlSetEvent</strong>](wdm-iobuilddeviceiocontrolsetevent.md)</p></td>
<td align="left"><p>The [<strong>IoBuildDeviceIoControlSetEvent</strong>](wdm-iobuilddeviceiocontrolsetevent.md) rule specifies that a driver that calls [<strong>IoBuildDeviceIoControlRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548318) must not call [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) if the driver supplies a pointer to a caller-allocated and initialized event object. The <strong>KeSetEvent</strong> does not need to be called by the driver for this IRP.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildFsdComplete</strong>](wdm-iobuildfsdcomplete.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdComplete</strong>](wdm-iobuildfsdcomplete.md) rule specifies that a driver should not call [<strong>IoCompleteRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548343) if the IRP was created with [<strong>IoBuildAsynchronousFsdRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548310).</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildFsdForward</strong>](wdm-iobuildfsdforward.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdForward</strong>](wdm-iobuildfsdforward.md) rule specifies that a completion routine must be set before a driver calls [<strong>IoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548336) or [<strong>PoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff559654) if the IRP is generated by a call to [<strong>IoBuildAsynchronousFsdRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548310).</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildFsdFree</strong>](wdm-iobuildfsdfree.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdFree</strong>](wdm-iobuildfsdfree.md) rule specifies that a driver should use [<strong>IoFreeIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff549113) only on IRPs it previously allocated with [<strong>IoBuildAsynchronousFsdRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548310).</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildFsdIrpSignalEventInCompletion</strong>](wdm-iobuildfsdirpsignaleventincompletion.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdIrpSignalEventInCompletion</strong>](wdm-iobuildfsdirpsignaleventincompletion.md) rule specifies that the driver should call [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildFsdIrpSignalEventInCompletion2</strong>](wdm-iobuildfsdirpsignaleventincompletion2.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdIrpSignalEventInCompletion2</strong>](wdm-iobuildfsdirpsignaleventincompletion2.md) rule specifies that [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) needs to be called in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildFsdIrpSignalEventInCompletion3</strong>](wdm-iobuildfsdirpsignaleventincompletion3.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdIrpSignalEventInCompletion3</strong>](wdm-iobuildfsdirpsignaleventincompletion3.md) rule specifies that [<strong>KeSetEvent</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553253) needs to be called in the completion routine when the <strong>Irp-&gt;PendingReturned</strong> flag is set and the completion routine is processing a locally created asynchronous IRP.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildFsdIrpSignalEventInCompletionTimeout</strong>](wdm-iobuildfsdirpsignaleventincompletiontimeout.md)</p></td>
<td align="left"><p>The [<strong>IoBuildFsdIrpSignalEventInCompletionTimeout</strong>](wdm-iobuildfsdirpsignaleventincompletiontimeout.md) rule reports a defect when the driver waits indefinitely until the lower driver returns, as the IRP’s event is required to be signaled in the completion routine.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildSynchronousFsdRequestNoFree</strong>](wdm-iobuildsynchronousfsdrequestnofree.md)</p></td>
<td align="left"><p>The [<strong>IoBuildSynchronousFsdRequestNoFree</strong>](wdm-iobuildsynchronousfsdrequestnofree.md) rule specifies that a driver that calls [<strong>IoBuildSynchronousFsdRequest</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548330) must not call [<strong>IoFreeIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff549113).</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>IoBuildSynchronousFsdRequestWait</strong>](wdm-iobuildsynchronousfsdrequestwait.md)</p></td>
<td align="left"><p>The [<strong>IoBuildSynchronousFsdRequestWait</strong>](wdm-iobuildsynchronousfsdrequestwait.md) rule specifies that [<strong>KeWaitForSingleObject</strong>](https://msdn.microsoft.com/library/windows/hardware/ff553350) should be called in the case that [<strong>IoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff548336) or [<strong>PoCallDriver</strong>](https://msdn.microsoft.com/library/windows/hardware/ff559654) returns STATUS_PENDING.</p></td>
</tr>
<tr class="odd">
<td align="left"><p>[<strong>IoBuildSynchronousFsdRequestWaitTimeout</strong>](wdm-iobuildsynchronousfsdrequestwaittimeout.md)</p></td>
<td align="left"><p>The [<strong>IoBuildSynchronousFsdRequestWaitTimeout</strong>](wdm-iobuildsynchronousfsdrequestwaittimeout.md) rule reports a defect if it detects that this driver will wait indefinitely until the lower driver returns, as the IRP’s event is required to be signaled in the completion routine.</p></td>
</tr>
<tr class="even">
<td align="left"><p>[<strong>RequestedPowerIrp</strong>](wdm-requestedpowerirp.md)</p></td>
<td align="left"><p>The [<strong>RequestedPowerIrp</strong>](wdm-requestedpowerirp.md) rule specifies that driver calls [<strong>PoRequestPowerIrp</strong>](https://msdn.microsoft.com/library/windows/hardware/ff559734) with the <code>*Irp</code> pointer variable set to <strong>NULL</strong>.</p></td>
</tr>
</tbody>
</table>

 

**To select the LocalIrpProcessing rule set**

1.  Select your driver project (.vcxProj) in Microsoft Visual Studio. From the **Driver** menu, click **Launch Static Driver Verifier…**.

2.  Click the **Rules** tab. Under **Rule Sets**, select **LocalIrpProcessing**.

    To select the default rule set from a Visual Studio developer command prompt window, specify **LocalIrpProcessing.sdv** with the **/check** option. For example:

    ```
    msbuild /t:sdv /p:Inputs="/check:LocalIrpProcessing.sdv" mydriver.VcxProj /p:Configuration="Win8 Release" /p:Platform=Win32
    ```

    For more information, see [Using Static Driver Verifier to Find Defects in Drivers](https://msdn.microsoft.com/library/windows/hardware/hh454281) and [Static Driver Verifier commands (MSBuild)](https://msdn.microsoft.com/library/windows/hardware/hh466459).

 

 





